type Jobs = Vec<String> ;

#[derive(Debug)]
pub struct JobManager {
    jobs : Vec<Jobs>,
}

impl JobManager {
    pub fn parse_job(command: &str) -> Jobs {
        let mut jobs: Vec<String> = command.split('&')
                                  .map(|s| s.trim().to_string())
                                  .collect();
        Jobs::from(jobs) 
    }

    pub fn manage_jobs(commands: Vec<String>) -> Vec<Jobs> {
        let mut job_commands: Vec<Jobs> = Vec::new();
        for command in commands {
            job_commands.push(Self::parse_job(&command));
        }
        job_commands
    }
}


/* Créer un itérateur permettant de regarder en arrière */
struct Instruction {
    command: String,
    args: Vec<String>,
    input: Input,
    output: Output,
}

impl Instruction { 
    pub fn new() -> Self {
        Self {command: String::new(), 
              args: Vec::new(), 
              input: Input::Stdin, 
              output: Output::Stdout}
    }

    pub fn setCommand(&mut self, command: String)  -> Option<()>{
        if command.is_empty() {
            return None;
        }
        let mut args : Vec<String> = command.split_whitespace().map(|s| s.to_string()).collect();
        let command = args.remove(0);
        self.args = args;
        self.command = command;
        Some(())
    }

    pub fn from(command: String, args: Vec<String>, input: Input, output: Output) -> Option<Self> {
        if command.is_empty() {
            return None;
        }
        Some(Self {command, args, input, output})
    }

    pub fn setIO(&mut self, input: Input, output: Output) {
        self.input = input;
        self.output = output;
    }

    pub fn setI(&mut self, input: Input) {
        self.input = input;
    }

    pub fn setO(&mut self, output: Output) {
        self.output = output;
    }
}

struct Instructions (Vec<Instruction>);

impl Instructions {

    pub fn parse_file(file_to_append: &mut std::iter::Peekable<std::str::Chars<'_>>) -> Option<(String, Option<char>)> {
        let mut file = String::new();
        if let Some(char) = file_to_append.peek() {
            if ['>', '<', '|'].contains(char) {
                return None;
            }
        } else {
            return None;
        }

        while let Some(char) = file_to_append.next() {

            if char == ' ' {
                if let Some(&end) = file_to_append.peek() {
                    if !(['>', '<', '|'].contains(&end)) {
                        file.clear();
                    }
                }
            } else {
                file.push(char);
            }
            
            if let Some(&end) = file_to_append.peek(){
                if ['>', '<', '|'].contains(&end) {
                    return Some((file, Some(end)));
                } 
            }

        }
        if file.is_empty() {
            return None;
        } else {
            return Some((file, None));
        } 
    }

    pub fn parse_commands_io(job_command: Jobs) -> Result<Self, CommandError(String)> {
        // En gros je parse jusqu'à tomber sur > >> < ou | 
        // là je clos mon instruction 
        // SI elle est vide erreur
        // Sinon je devrai avoir le premier mot comme command et le reste comme args 
        // si c'est > >> ou < chaque mot suivant jusqu'à un futur | remplace la destination
        // dès que je tombe sur | ou sur rien alors soit je crée un nouvelle command soit je stop.
        
        let mut command = String::new();
        let mut instruction = Instruction::new();

        for job in job_command{
            let mut chars = job.chars().peekable();
            while let Some(char) = chars.next() {
                match char {
                    '>' => {
                        if (chars.peek()=='>') {
                            chars.next();
                            let file_to_append = Self::parse_file(chars);
                            if file_to_append == None {return ShellError::CommandError(job)}
                            let (file, next_char) = file_to_append;
                            
                            if next_char==None {break};
                            // cas où >>
                        } else {

                        }
                    },

                    '<' => ,
                    '|' => ,
                    _ => ,
                }
            }
        }
        Instructions(Vec::new())
    }

    pub fn manage_commands_io(job_commands: Vec<Jobs>) -> Vec<Self> {
        let mut command = String::new();
        let mut commands: Vec<Instructions> = Vec::new();
        
        for job_command in job_commands {
        }
        commands
    }
}